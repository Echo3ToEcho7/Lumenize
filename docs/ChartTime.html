<!DOCTYPE html>

<html>
<head>
  <title>ChartTime.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="resources/base.css" />
  <link rel="stylesheet" media="all" href="resources/module.css" />
</head>
<body>
  <header>
    <h1>ChartTime.coffee</h1>
  </header>
  <div id="content">
    <div id="sidebar">
      
      <h4>Classes</h4>
      <ul class="classlist">
        
        <li><a href="#ChartTime">ChartTime</a></li>
        
      </ul>
      
      
    </div>
    <div id="main">
      
      
      <div id="classes">
        <h2>Classes</h2>
        
        <div class="class">
          <div class="header">
            <a id="ChartTime"><h3>ChartTime</h3></a>
            
          </div>
          <div class="class_content">
            
            <div class="methods">
              
              <div class="staticmethods">
                <h3>Static Methods</h3>
                
                <div class="method">
                  <h4>ChartTime.setTZPath(tzPath)</h4>
                  <p>Allows you to set the path (can be relative) to the tz files. Must be called prior to doing timezone sensitive comparisons. </p>
                </div>
                
                <div class="method">
                  <h4>ChartTime.addGranularity(granularitySpec)</h4>
                  <p>addGranularity allows you to add your own hierarchical granularities to ChartTime. Once you add a granularity to ChartTime
you can then instantiate ChartTime objects in your newly specified granularity. You specify new granularities with 
granularitySpec object like this:</p>

<pre><code>{ChartTime} = require('../')
ChartTime.setTZPath('../vendor/tz')

granularitySpec = {
  release: {
    segments: ['release'],
    mask: 'R##',
    lowest: 1,
    dayPastEnd: new ChartTime('2011-07-01')
    pastHighest: (ct) -&gt;
      return ChartTime.granularitySpecs.iteration.timeBoxes.length + 1  # Yes, it's correct to use the length of iteration.timeBoxes
    rataDieNumber: (ct) -&gt;
      return ChartTime.granularitySpecs.iteration.timeBoxes[ct.release-1][1-1].start.rataDieNumber()
  },
  iteration: {
    segments: ['release', 'iteration'],
    mask: 'R##I##',
    lowest: 1,
    dayPastEnd: new ChartTime('2011-07-01')        
    timeBoxes: [
      [
        {start: new ChartTime('2011-01-01'), label: 'R1 Iteration 1'},
        {start: new ChartTime('2011-02-01'), label: 'R1 Iteration 2'},
        {start: new ChartTime('2011-03-01'), label: 'R1 Iteration 3'},
      ],
      [
        {start: new ChartTime('2011-04-01'), label: 'R2 Iteration 1'},
        {start: new ChartTime('2011-05-01'), label: 'R2 Iteration 2'},
        {start: new ChartTime('2011-06-01'), label: 'R2 Iteration 3'},
      ]
    ]
    pastHighest: (ct) -&gt;
      temp = ChartTime.granularitySpecs.iteration.timeBoxes[ct.release-1]?.length + 1
      if temp? and not isNaN(temp) and ct.beforePastFlag != 'PAST_LAST'
        return temp
      else
        numberOfReleases = ChartTime.granularitySpecs.iteration.timeBoxes.length
        return ChartTime.granularitySpecs.iteration.timeBoxes[numberOfReleases-1].length + 1

    rataDieNumber: (ct) -&gt;
      return ChartTime.granularitySpecs.iteration.timeBoxes[ct.release-1][ct.iteration-1].start.rataDieNumber()
  },
  iteration_day: {  # By convention, it knows to use day functions on it. This is the lowest allowed custom granularity
    segments: ['release', 'iteration', 'iteration_day'],
    mask: 'R##I##-##',
    lowest: 1,
    dayPastEnd: new ChartTime('2011-07-01'),
    pastHighest: (ct) -&gt;
      iterationTimeBox = ChartTime.granularitySpecs.iteration.timeBoxes[ct.release-1]?[ct.iteration-1]
      if !iterationTimeBox? or ct.beforePastFlag == 'PAST_LAST'
        numberOfReleases = ChartTime.granularitySpecs.iteration.timeBoxes.length
        numberOfIterationsInLastRelease = ChartTime.granularitySpecs.iteration.timeBoxes[numberOfReleases-1].length
        iterationTimeBox = ChartTime.granularitySpecs.iteration.timeBoxes[numberOfReleases-1][numberOfIterationsInLastRelease-1]

      thisIteration = iterationTimeBox.start.inGranularity('iteration')
      nextIteration = thisIteration.add(1)
      if nextIteration.beforePastFlag == 'PAST_LAST'
        return ChartTime.granularitySpecs.iteration_day.dayPastEnd.rataDieNumber() - iterationTimeBox.start.rataDieNumber() + 1
      else
        return nextIteration.rataDieNumber() - iterationTimeBox.start.rataDieNumber() + 1 

    rataDieNumber: (ct) -&gt;
      return ChartTime.granularitySpecs.iteration.timeBoxes[ct.release-1][ct.iteration-1].start.rataDieNumber() + ct.iteration_day - 1
  }
}    
ChartTime.addGranularity(granularitySpec)
</code></pre>

<p>The <code>mask</code> must cover all of the segments to get down to the granularity being specified. The digits of the granularity segments
are represented with <code>#</code>. Any other characters can be used as a delimeter, but it should always be one character to comply with 
the expectations of the Lumenize hierarchy visualizations. All of the standard granularities start with a 4-digit year to
distinguish your custom granularity, your highest level must start with some number of digits other than 4 or a prefix letter 
(<code>R</code> in the example above).</p>

<p>In order for the ChartTimeIterator to work, you must provide <code>pastHighest</code> and <code>rataDieNumber</code> callback functions. You should
be able to mimic (or use as-is) the example above for most use cases. Notice how the <code>rataDieNumber</code> function simply leverages
<code>rataDieNumber</code> functions for the standard granularities.</p>

<p>In order to convert into this granularity from some other granularity, you must provide an <code>inGranularity</code> callback [NOT YET IMPLEMENTED].
But ChartTime will convert to any of the standard granularities from even custom granularities as long as a <code>rataDieNumber()</code> function
is provided.</p>

<p><strong>The <code>timeBoxes</code> propoerty in the <code>granularitySpec</code> Object above has no special meaning</strong> to ChartTime or ChartTimeIterator. It's simply used
by the <code>pastHighest</code> and <code>rataDieNumber</code> functions. The boundaries could come from where ever you want and even have been encoded as
literals in the <code>pastHighest</code> and <code>rataDieNumber</code> callback functions.</p>

<p>The convention of naming the lowest order granularity with <code>_day</code> at the end IS signficant. ChartTime knows to treat that as a day-level
granularity. If there is a use-case for it, ChartTime could be upgraded to allow you to drill down into hours, minutes, etc. from any
<code>_day</code> granularity but right now those lower order time granularities are only supported for the canonical ISO-6801 form.</p>
                </div>
                
              </div>
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>constructor(spec_RDN_Or_String, granularity, tz)</h4>
                  <p>The constructor for ChartTime supports the passing in of a String, a rata die number (RDN), or a spec Object</p>

<h2>String</h2>

<p>When you pass in a <strong>String</strong>, ChartTime uses the masks that are defined for each granularity to figure out the granularity...
unless you explicitly provide a granularity. This parser does not work on all valid ISO-8601 forms. Ordinal dates are not 
supported at all but week number form (<code>"2009W52-7"</code>) is supported. The canonical form (<code>"2009-01-01T12:34:56.789"</code>) will work
as will any shortened subset of it (<code>"2009-01-01"</code>, <code>"2009-01-01T12:34"</code>, etc.). We've added a form for Quarter
granularity (<code>"2009Q4"</code>). Plus it will even parse strings in whatever custom granularity you provide based
upon the mask that you provide for that granularity.</p>

<p>If the granularity is specified but not all of the segments are provided, ChartTime will fill in the missing value 
with the <code>lowest</code> value from granularitySpecs.</p>

<p>The Lumenize hierarchy tools rely upon the property that a single character is used between segments so the ISO forms that 
omit the delimeters are not supported.</p>

<p>If the string has a timezone indicator on the end (<code>...+05:00</code> or <code>...Z</code>), ChartTime will ignore it. Timezone information
is intended to only be used for comparison (see examples for timezone comparison).</p>

<p>There are two special Strings that are recognized: <code>BEFORE_FIRST</code> and <code>PAST_LAST</code>. You must provide a granularity if you
are instantiating a ChartTime with these values. They are primarily used for custom granularities where your users
may mistakenly request charts for iterations and releases that have not yet been defined. They are particularly useful when 
you want to iterate to the last defined iteration/release.</p>

<h2>Rata Die Number</h2>

<p>The <strong>rata die number (RDN)</strong> for a date is the number of days since 0001-01-01. You will probably never work
directly with this number but it's what ChartTime uses to convert between granularities. When you are instantiating
a ChartTime from an RDN, you must provide a granularity. Using RDN will work even for the granularities finer than day.
ChartTime will populate the finer grained segments (hour, minute, etc.) with the approriate <code>lowest</code> value.</p>

<h2>Spec</h2>

<p>You can also explicitly spell out the segments in a <strong>spec</strong> Object in the form of 
<code>{granularity: 'day', year: 2009, month: 1, day: 1}</code>. If the granularity is specified but not all of the segments are 
provided, ChartTime will fill in the missing value with the appropriate <code>lowest</code> value from granularitySpecs.</p>

<h2>granularity</h2>

<p>If you provide a granularity it will take precedence over whatever fields you've provided in your spec or whatever segments
you have provided in your string. ChartTime will leave off extra values and fill in missing ones with the appropriate <code>lowest</code>
value.</p>

<h2>tz</h2>

<p>Most of the time, ChartTime assumes that any dates you pass in are timezone less. You'll specify Christmas as 12-25, then you'll
shift the boundaries of Christmas for a specific timezone for boundary comparison.</p>

<p>However, if you provide a tz parameter to this constructor, ChartTime will assume you are passing in a true GMT date/time and shift into 
the provided timezone. So...</p>

<pre><code>{ChartTime} = require('../')

d = new ChartTime('2011-01-01T02:00:00:00.000Z', 'day', 'America/New_York')
console.log(d.toString())
# 2010-12-31
</code></pre>

<p>Rule of thumb on when you want to use timezones:</p>

<ol>
<li>If you have true GMT date/times and you want to create a ChartTime, provide the timezone to this constructor.</li>
<li>If you have abstract days like Christmas or June 10th and you want to delay the timezone consideration, don't provide a timezone to this constructor.</li>
<li>In either case, if the dates you want to compare to are in GMT, but you've got ChartTimes or ChartTimeRanges, you'll have to provide a timezone on
the way back out of ChartTime/ChartTimeRange</li>
</ol>
                </div>
                
                <div class="method">
                  <h4>granularityAboveDay()</h4>
                  <p>Convenience function to tell if the ChartTime Object's granularity is above (courser than) "day" level.</p>
                </div>
                
                <div class="method">
                  <h4>getJSDate(tz)</h4>
                  <p>Returns a JavaScript Date Object properly shifted. This Date Object can be compared to other Date Objects that you know
are already in the desired timezone. If you have data that comes from an API in GMT. You can first create a ChartTime object from
it and then (using this getJSDate() function) you can compare it to JavaScript Date Objects created in local time.</p>

<p>The full name of this function should be getJSDateInGMTasummingThisCTDateIsInTimezone(tz). It converts <strong>TO</strong> GMT 
(actually something that can be compared to GMT). It does <strong>NOT</strong> convert <strong>FROM</strong> GMT. Use getJSDateInTZfromGMT()
if you want to go in the other direction.</p>

<p>Note, you must set the path to the tz files with <code>ChartTime.setTZPath('path/to/tz/files')</code> before you do timezone 
sensitive comparisions.</p>

<h2>Usage</h2>

<pre><code>ct = new ChartTime('2011-01-01')
d = new Date(Date.UTC(2011, 0, 1))

console.log(ct.getJSDate('GMT').getTime() == d.getTime())
# true

console.log(ct.inGranularity('hour').add(-5).getJSDate('America/New_York').getTime() == d.getTime())
# true
</code></pre>
                </div>
                
                <div class="method">
                  <h4>getJSDateString(tz)</h4>
                  
                </div>
                
                <div class="method">
                  <h4>getJSDateInTZfromGMT(tz)</h4>
                  <p>This assumes that the ChartTime is an actual GMT date/time as opposed to some abstract day like Christmas and shifts
it into the specified timezone.</p>

<p>Note, this function will be off by an hour for the times near midnight on the days where there is a shift to/from daylight 
savings time. The tz rules engine is designed to go in the other direction so we're mis-using it and will be using the wrong
moment in rules-space for that hour. The cost of fixing this issue was deamed to high for chart applications.</p>
                </div>
                
                <div class="method">
                  <h4>toString()</h4>
                  <p>Uses granularity <code>mask</code> to generate the string representation.</p>
                </div>
                
                <div class="method">
                  <h4>dowNumber()</h4>
                  <p>Returns the day of the week as a number. Monday = 1, Sunday = 7</p>
                </div>
                
                <div class="method">
                  <h4>dowString()</h4>
                  <p>Returns the day of the week as a String.</p>
                </div>
                
                <div class="method">
                  <h4>rataDieNumber()</h4>
                  <p>Returns the number of days since 0001-01-01. Works for granularities finer than day (hour, minute, second, millisecond) but ignores the 
segments of finer granularity than day.</p>
                </div>
                
                <div class="method">
                  <h4>inGranularity(granularity)</h4>
                  <p>Returns a new ChartTime object for the same date-time as this object but in the specified granularity.
Fills in missing finer granularity bits with <code>lowest</code> values.</p>
                </div>
                
                <div class="method">
                  <h4>daysInMonth()</h4>
                  <p>Returns the number of days in the current month for this ChartTime</p>
                </div>
                
                <div class="method">
                  <h4>isLeapYear()</h4>
                  <p>True if this is a leap year.</p>
                </div>
                
                <div class="method">
                  <h4>is53WeekYear()</h4>
                  <p>True if this is a 53-week year.</p>
                </div>
                
                <div class="method">
                  <h4>$eq(other)</h4>
                  <p>Returns true if this equals other. Throws an error if the granularities don't match.</p>

<pre><code>d3 = new ChartTime({granularity: 'day', year: 2011, month: 12, day: 31})
d4 = new ChartTime('2012-01-01').add(-1)
console.log(d3.$eq(d4))
# true
</code></pre>
                </div>
                
                <div class="method">
                  <h4>$gt(other)</h4>
                  <p>Returns true if this is greater than other. Throws an error if the granularities don't match</p>

<pre><code>d1 = new ChartTime({granularity: 'day', year: 2011, month: 2, day: 28})
d2 = new ChartTime({granularity: 'day', year: 2011, month: 3, day: 1})
console.log(d1.$gt(d2))
# false
console.log(d2.$gt(d1))
# true
</code></pre>
                </div>
                
                <div class="method">
                  <h4>$gte(other)</h4>
                  <p>True if this is greater than or equal to other.</p>
                </div>
                
                <div class="method">
                  <h4>$lt(other)</h4>
                  <p>True if this is less than other.</p>
                </div>
                
                <div class="method">
                  <h4>$lte(other)</h4>
                  <p>True if this is less than or equal to other.</p>
                </div>
                
                <div class="method">
                  <h4>decrement(granularity)</h4>
                  <p>Decrements by 1.</p>
                </div>
                
                <div class="method">
                  <h4>increment(granularity)</h4>
                  <p>Increments by 1.</p>
                </div>
                
                <div class="method">
                  <h4>addInPlace(qty, granularity)</h4>
                  <p>Adds qty to the ChartTime object. It uses increment and decrement so it's not going to be efficient for large values
of qty, but it should be fine for charts where we'll increment/decrement small values of qty.</p>

<p>qty can be negative for subtraction.</p>
                </div>
                
                <div class="method">
                  <h4>add(qty, granularity)</h4>
                  <p>Adds (or subtracts) quantity (negative quantity) and returns a new ChartTime.</p>
                </div>
                
              </div>
              
            </div>
          </div>
        </div>
        
      </div>
      
      
    </div>
  </div>
</body>
</html>
